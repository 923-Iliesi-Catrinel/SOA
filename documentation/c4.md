# PharmaGuard Architecture Documentation

## 1. System Context Diagram (Level 1)

This diagram defines the external actors and the system boundary.

```mermaid
C4Context
    title System Context Diagram - PharmaGuard

    %% Actors
    Person(pharmacist, "Hospital Pharmacist", "Places orders for critical medicine.")
    Person(manager, "Logistics Manager", "Monitors fleet status and receives shock alerts.")
    System_Ext(truck_sensor, "IoT Sensor Box", "Hardware device in truck. Sends GPS, Temp, Vibration.")

    %% The Main System
    System(pharmaguard, "PharmaGuard System", "Manages medical orders, tracks live shipments, and processes high-frequency telemetry.")

    %% External Systems
    System_Ext(email_system, "Email Provider", "Sends order confirmations (SendGrid/SMTP).")

    %% Relationships
    Rel(pharmacist, pharmaguard, "1. Places Orders, Signs for delivery")
    Rel(manager, pharmaguard, "2. Views Dashboard, Gets Alerts")
    Rel(truck_sensor, pharmaguard, "3. Streams Telemetry Data")
    Rel(pharmaguard, email_system, "4. Sends emails via")
```

## 2. Container Diagram (Level 2)

This diagram shows the microservices, data stores, and specific technologies (Kafka, Redis, FaaS).

```mermaid
C4Container
    title Container Diagram - PharmaGuard Architecture

    Person(user, "User", "Pharmacist or Logistics Manager")

    Container_Boundary(frontend_boundary, "Frontend System") {
        Container(spa, "Micro Frontend Shell", "React, Webpack 5", "Loads the Dashboard and Order modules dynamically.")
    }

    Container(nginx, "API Gateway", "Nginx", "Reverse Proxy, SSL Termination, Static Content serving.")

    Container_Boundary(backend_boundary, "Microservices Backend") {
        Container(order_svc, "Order Service", "Java / Spring Boot", "Handles business logic for orders and users.")
        Container(fleet_svc, "Fleet Service", "Node.js / Express", "Manages Truck metadata and simulates telemetry.")
        Container(notif_svc, "Notification Service", "Node.js / Socket.io", "Manages WebSocket connections to frontend.")
    }

    Container_Boundary(streaming_boundary, "Event Processing") {
        Container(kafka, "Kafka Cluster", "Apache Kafka", "Ingests high-throughput telemetry streams.")
        Container(faas, "Shock Detector", "OpenFaaS Function (Python)", "Stateless function. Triggers if Vibration > Threshold.")
        Container(rabbitmq, "Message Broker", "RabbitMQ", "Handles asynchronous tasks (Order -> Inventory).")
    }

    ContainerDb(postgres, "Main DB", "PostgreSQL", "Stores Users, Orders, Products.")
    ContainerDb(mongo, "Telemetry DB", "MongoDB", "Stores raw sensor logs for auditing.")
    ContainerDb(redis, "Cache", "Redis", "Stores active truck locations for fast map retrieval.")

    %% Flows
    Rel(user, spa, "Uses HTTPS")
    Rel(spa, nginx, "API Calls / WSS")

    Rel(nginx, order_svc, "Routes /api/orders")
    Rel(nginx, fleet_svc, "Routes /api/fleet")
    Rel(nginx, notif_svc, "Routes /ws")

    Rel(order_svc, postgres, "Read/Write")
    Rel(order_svc, rabbitmq, "Publishes events")

    Rel(fleet_svc, kafka, "Produces sensor data")
    Rel(fleet_svc, mongo, "Archives data")

    Rel(kafka, faas, "Stream Trigger")
    Rel(faas, notif_svc, "Invokes on Alert")
    Rel(notif_svc, redis, "Pub/Sub Channel")
    Rel(notif_svc, spa, "Push Alert")
```

## 3. Component Diagram: Order Service (Level 3)

Detailing the internal structure of the Spring Boot Order Service.

```mermaid
C4Component
    title Component Diagram - Order Service (Spring Boot)

    Container(spa, "Single Page App", "React", "Frontend")
    ContainerDb(db, "PostgreSQL", "SQL Database", "Stores Order Data")
    Container(mq, "RabbitMQ", "Message Broker", "Async Messaging")

    Container_Boundary(order_app, "Order Service Application") {
        Component(controller, "Order Controller", "Spring MVC RestController", "Exposes REST endpoints (GET, POST).")
        Component(security, "Security Filter", "Spring Security / JWT", "Validates Authorization tokens.")
        Component(service, "Order Service Logic", "Spring Service", "Implements business rules (validation, stock check).")
        Component(repo, "Order Repository", "Spring Data JPA", "Interface for Database Access.")
        Component(publisher, "Event Publisher", "RabbitTemplate", "Publishes messages to the Broker.")
    }

    Rel(spa, controller, "Makes JSON Requests")
    Rel(controller, security, "Uses")
    Rel(controller, service, "Calls")
    Rel(service, repo, "Uses")
    Rel(service, publisher, "Uses")

    Rel(repo, db, "SQL Queries (JDBC)")
    Rel(publisher, mq, "Publishes 'order.created'")
```

## 4. Data Model (UML Class Diagram)

Separation of Relational Data (Orders) and Time-Series Data (Telemetry).

```mermaid
classDiagram
    direction LR

    %% Relational Data (Postgres)
    class User {
        +UUID id
        +String username
        +String password_hash
        +String role
    }

    class Order {
        +UUID id
        +Date created_at
        +OrderStatus status
        +List~OrderItem~ items
        +approve()
        +reject()
    }

    class OrderItem {
        +UUID id
        +String product_name
        +Int quantity
    }

    %% Real-time Data (Kafka/Mongo)
    class Truck {
        +String license_plate
        +Driver current_driver
        +GeoPoint last_location
        +Boolean is_active
    }

    class TelemetryEvent {
        %% High Frequency Data
        +String truck_id
        +Timestamp timestamp
        +Float latitude
        +Float longitude
        +Float temperature_celsius
        +Float vibration_g_force
    }

    User "1" -- "*" Order : places
    Order "1" -- "*" OrderItem : contains
    Order "1" -- "1" Truck : assigned_to
    Truck "1" -- "*" TelemetryEvent : emits_stream
```
